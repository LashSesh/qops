//! Hypercube Artifacts
//!
//! Output artifacts generated by Hypercube compilation and HDAG execution.

use crate::coordinates::Coord5D;
use qops_core::Signature5D;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Type of artifact
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ArtifactType {
    /// Compiled operator family
    CompiledFamily,
    /// Optimized coordinate
    OptimizedCoordinate,
    /// HDAG execution trace
    ExecutionTrace,
    /// Resonance map
    ResonanceMap,
    /// Operator sequence
    OperatorSequence,
    /// Checkpoint state
    Checkpoint,
    /// Research data
    ResearchData,
}

/// Metadata for an artifact
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ArtifactMetadata {
    /// Creation timestamp
    pub created_at: Option<String>,
    /// Source HDAG ID
    pub source_hdag: Option<String>,
    /// Source node ID
    pub source_node: Option<String>,
    /// Compilation mode used
    pub compilation_mode: Option<String>,
    /// Number of operators in sequence
    pub operator_count: usize,
    /// Total execution time
    pub execution_time_ms: u64,
    /// Tags
    pub tags: Vec<String>,
    /// Additional properties
    pub properties: std::collections::HashMap<String, String>,
}

/// A hypercube artifact
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HypercubeArtifact {
    /// Unique identifier
    pub id: String,
    /// Artifact name
    pub name: String,
    /// Artifact type
    pub artifact_type: ArtifactType,
    /// Output coordinate
    pub coordinate: Coord5D,
    /// Output signature (QOPS compatible)
    pub signature: Signature5D,
    /// Resonance score
    pub resonance: f64,
    /// Is artifact finalized
    pub finalized: bool,
    /// Metadata
    pub metadata: ArtifactMetadata,
    /// Serialized operator sequence (for reproducibility)
    pub operator_sequence: Option<String>,
    /// Parent artifact ID (if derived)
    pub parent_id: Option<String>,
}

impl HypercubeArtifact {
    /// Create a new artifact
    pub fn new(name: &str, artifact_type: ArtifactType, coordinate: Coord5D) -> Self {
        let signature = coordinate.to_signature();
        let resonance = coordinate.resonance();

        Self {
            id: Uuid::new_v4().to_string(),
            name: name.to_string(),
            artifact_type,
            coordinate,
            signature,
            resonance,
            finalized: false,
            metadata: ArtifactMetadata {
                created_at: Some(chrono::Utc::now().to_rfc3339()),
                ..Default::default()
            },
            operator_sequence: None,
            parent_id: None,
        }
    }

    /// Create a compiled family artifact
    pub fn compiled_family(name: &str, coordinate: Coord5D, operators: Vec<String>) -> Self {
        let mut artifact = Self::new(name, ArtifactType::CompiledFamily, coordinate);
        artifact.operator_sequence = Some(operators.join(","));
        artifact.metadata.operator_count = operators.len();
        artifact
    }

    /// Create an optimized coordinate artifact
    pub fn optimized_coordinate(name: &str, coordinate: Coord5D) -> Self {
        Self::new(name, ArtifactType::OptimizedCoordinate, coordinate)
    }

    /// Create a checkpoint artifact
    pub fn checkpoint(name: &str, coordinate: Coord5D, hdag_id: &str, node_id: &str) -> Self {
        let mut artifact = Self::new(name, ArtifactType::Checkpoint, coordinate);
        artifact.metadata.source_hdag = Some(hdag_id.to_string());
        artifact.metadata.source_node = Some(node_id.to_string());
        artifact
    }

    /// Set parent artifact
    pub fn with_parent(mut self, parent_id: &str) -> Self {
        self.parent_id = Some(parent_id.to_string());
        self
    }

    /// Add tag
    pub fn with_tag(mut self, tag: &str) -> Self {
        self.metadata.tags.push(tag.to_string());
        self
    }

    /// Finalize the artifact
    pub fn finalize(&mut self) {
        self.finalized = true;
    }

    /// Check if artifact meets resonance threshold
    pub fn meets_threshold(&self, threshold: f64) -> bool {
        self.resonance >= threshold
    }

    /// Convert to JSON
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(self)
    }

    /// Create from JSON
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

impl std::fmt::Display for HypercubeArtifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Artifact[{}] '{}' ({:?}): R={:.4} @ {}",
            &self.id[..8], self.name, self.artifact_type,
            self.resonance, self.coordinate)
    }
}

/// Collection of artifacts with management operations
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ArtifactCollection {
    /// All artifacts
    artifacts: Vec<HypercubeArtifact>,
    /// Best artifact ID
    best_id: Option<String>,
    /// Best resonance
    best_resonance: f64,
}

impl ArtifactCollection {
    /// Create new empty collection
    pub fn new() -> Self {
        Self::default()
    }

    /// Add an artifact
    pub fn add(&mut self, artifact: HypercubeArtifact) {
        if artifact.resonance > self.best_resonance {
            self.best_resonance = artifact.resonance;
            self.best_id = Some(artifact.id.clone());
        }
        self.artifacts.push(artifact);
    }

    /// Get artifact by ID
    pub fn get(&self, id: &str) -> Option<&HypercubeArtifact> {
        self.artifacts.iter().find(|a| a.id == id)
    }

    /// Get best artifact
    pub fn best(&self) -> Option<&HypercubeArtifact> {
        self.best_id.as_ref().and_then(|id| self.get(id))
    }

    /// Get all artifacts
    pub fn all(&self) -> &[HypercubeArtifact] {
        &self.artifacts
    }

    /// Get artifacts by type
    pub fn by_type(&self, artifact_type: ArtifactType) -> Vec<&HypercubeArtifact> {
        self.artifacts.iter()
            .filter(|a| a.artifact_type == artifact_type)
            .collect()
    }

    /// Get artifacts above resonance threshold
    pub fn above_threshold(&self, threshold: f64) -> Vec<&HypercubeArtifact> {
        self.artifacts.iter()
            .filter(|a| a.resonance >= threshold)
            .collect()
    }

    /// Sort by resonance (highest first)
    pub fn sorted_by_resonance(&self) -> Vec<&HypercubeArtifact> {
        let mut sorted: Vec<_> = self.artifacts.iter().collect();
        sorted.sort_by(|a, b| b.resonance.partial_cmp(&a.resonance).unwrap());
        sorted
    }

    /// Count artifacts
    pub fn len(&self) -> usize {
        self.artifacts.len()
    }

    /// Check if empty
    pub fn is_empty(&self) -> bool {
        self.artifacts.is_empty()
    }

    /// Average resonance
    pub fn avg_resonance(&self) -> f64 {
        if self.artifacts.is_empty() {
            return 0.0;
        }
        self.artifacts.iter().map(|a| a.resonance).sum::<f64>() / self.artifacts.len() as f64
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_artifact_creation() {
        let coord = Coord5D::new(0.8, 0.7, 0.6, 0.5, 0.4);
        let artifact = HypercubeArtifact::new("test", ArtifactType::CompiledFamily, coord);

        assert!(artifact.resonance > 0.0);
        assert!(!artifact.finalized);
    }

    #[test]
    fn test_artifact_collection() {
        let mut collection = ArtifactCollection::new();

        let a1 = HypercubeArtifact::new("a1", ArtifactType::CompiledFamily, Coord5D::new(0.9, 0.9, 0.9, 0.5, 0.1));
        let a2 = HypercubeArtifact::new("a2", ArtifactType::CompiledFamily, Coord5D::new(0.5, 0.5, 0.5, 0.5, 0.5));

        collection.add(a1);
        collection.add(a2);

        assert_eq!(collection.len(), 2);
        assert!(collection.best().is_some());
    }
}
